{"year": "2021", "forum": "u846Bqhry_", "title": "Asynchronous Modeling: A Dual-phase Perspective for Long-Tailed Recognition", "decision": "Reject", "meta_review": "The paper received mixed reviews. Reviewers were concerned about the clarity of the presentation, including both the analyses of gradients and the approach. Some reviewers also suggested improvements to the experiments. The two reviewers who gave a rating of 6 liked the gradient perspective to the long-tailed recognition, but their concerns seemed to overshadow their excitement. AC suggested authors improving the paper, especially its clarity and empirical part, following Reviewers' comments and submitting the paper elsewhere. ", "reviews": [{"review_id": "u846Bqhry_-0", "review_text": "* * Overview : * * The paper considers the issue of gradient distortion in long-tailed recognition including shifted gradient direction towards data-rich classes and the enlarged variance introduced by data-poor classes . It proposes to disentangle the data-rich and data-poor classes and train a model via a dual-phase learning process . The experimental results proved the effectiveness of the method . * * Strengths : * * The observation is interesting and the method is reasonable . The memory retentive loss via graph matching in the second phase makes sense , and the method is well evaluated in four commonly used datasets . * * Weaknesses , questions , and suggestions : * * 1 . One of my main concerns is that the separation of the data-rich and data-poor classes is unnatural because the long-tailed distribution is continuous . The main idea of the method is kind of similar to that of Gidaris et al . [ 1 ] as the authors also cited , but in the few-shot setting in their paper , the separation of base and novel classes is more natural and reasonable . The issue of gradient distortion is addressed and is the motivation of the method , however , the variety in gradient does not necessarily lead to worse performance , and even when the data-rich classes are extracted for training in Phase I , the imbalance and shifting to the relatively rich classes still exists while being less informative because of fewer classes and less data . The trade-off is not easy to balance and could be sensitive to the disentanglement points as in Figure 3 , where 294 and 864 are carefully selected for Places-LT and ImageNer-LT This introduces limitation to the generality of the method . 2.Are the formations of equation ( 2 ) and ( 5 ) presented correctly ? Maybe the authors intend to present \\sum_i { exp { ... } } as the denominator ? 3.The presentation and clarity need to be improved . For example , - The caption for Figure 1 is too long and could be more concise , e.g. , to use 'titles ' to distinguish CIFAR100 and CIFAR100-LT ; to use grad_rich / grad_poor or something as the legend and save any extra explanation . Some of the details can be embedded in the main paper , and I \u2019 m not sure how are the gradient statistics calculated , layer-by-layer , or directly use the average of the whole network . It would be better to see it clarified in the paper or appendix , and sorry if I missed it . - There are double y-axis in Figure 2 and 3 , but there is no legend or caption showing each plot is assigned to which axis . - What does 'extended parameters ' mean in the experiment section ? 4.The performance improvement seems not significant compared with previous works , e.g.ImageNet-LT on ResNet-10 and iNaturalist . 5.I \u2019 m not sure I \u2019 ve correctly comprehended the construction of the exemplar memory bank and the reason why use s ( c_j + \\Delta , X_1 ) to search for the new entry . More explanation for Equation ( 4 ) and a clearer presentation of the algorithm ( e.g.use an Algorithm module ) is preferred . [ 1 ] Gidaris et al. , Dynamic few-shot visual learning without forgetting , in CVPR 2018 * * Post-Rebuttal * * After reading the rebuttal and other reviewers ' comments , I am actually on the fence for this submission . On the one hand , it provides several interesting observations about the phase transition in long-tailed recognition , which would be valuable to the community . On the other hand , its experimental evaluation needs to be strengthened . The authors are encouraged to include more many-shot/medium-shot/few-shot analysis across the dual phases . Therefore , I upgrade my score to 6 ( marginally above acceptance threshold ) .", "rating": "6: Marginally above acceptance threshold", "reply_text": "Thank you for recognizing that \u201c the observation is interesting and the method is reasonable \u201d . We answer your questions below : 1 . One of my main concerns is that the separation of the data-rich and data-poor classes is unnatural because the long-tailed distribution is continuous . The main idea of the method is kind of similar to that of Gidaris et al . [ 1 ] as the authors also cited , but in the few-shot setting in their paper , the separation of base and novel classes is more natural and reasonable . The issue of gradient distortion is addressed and is the motivation of the method , however , the variety in gradient does not necessarily lead to worse performance , and even when the data-rich classes are extracted for training in Phase I , the imbalance and shifting to the relatively rich classes still exists while being less informative because of fewer classes and less data . The trade-off is not easy to balance and could be sensitive to the disentanglement points as in Figure 3 , where 294 and 864 are carefully selected for Places-LT and ImageNer-LT This introduces limitation to the generality of the method . * * Answer : * * Gidaris et al . [ 1 ] considers the few-shot setting , which aims to quickly adapt to novel classes . Our separation of data-rich classes and data-poor classes is motivated by the gradient distortion phenomenon . For long-tailed classification , we not only consider the representation learning but the classification . Actually for head data , the tail data actually helps little in the representation learning since the limited samples . The classification of tail classes , however , will distract the classification of head classes . This is reflected by the gradient distortion between them . As we show in Figure 3 , though the final performance is affected by the specific threshold selected , but the change is minor . The final performance actually keeps rather stable in a wide range of threshold . 2.Are the formations of equation ( 2 ) and ( 5 ) presented correctly ? Maybe the authors intend to present \\sum_i { exp { ... } } as the denominator ? * * Answer : * * Sorry for the mistake , we will update it . 3.The presentation and clarity need to be improved . For example , the caption for Figure 1 is too long and could be more concise , e.g. , to use 'titles ' to distinguish CIFAR100 and CIFAR100-LT ; to use grad_rich / grad_poor or something as the legend and save any extra explanation . Some of the details can be embedded in the main paper , and I \u2019 m not sure how are the gradient statistics calculated , layer-by-layer , or directly use the average of the whole network . It would be better to see it clarified in the paper or appendix , and sorry if I missed it . * * Answer : * * Figure 1 will be updated . Here we simply show the gradient computed in the FC layer . 4.There are double y-axis in Figure 2 and 3 , but there is no legend or caption showing each plot is assigned to which axis . * * Answer : * * We will update the figure . In the paper , we have described \u201c Similarly , the axis for describing different shots is in the left . The change of overall result is depicted in the right of the figure , which is an independent axis \u201d . 5.What does 'extended parameters ' mean in the experiment section ? * * Answer : * * The extended parameters here means that they introduce extra modules and incorporate more parameters . 6.The performance improvement seems not significant compared with previous works , e.g.ImageNet-LT on ResNet-10 and iNaturalist . * * Answer : * * You are correct . For ImageNet-LT on ResNet-10 , the model is limited in its parameters , so the improvement is not significant . For iNaturalist , considering its scale ( 400K image ) , further improvement can be very difficult . 7.I \u2019 m not sure I \u2019 ve correctly comprehended the construction of the exemplar memory bank and the reason why use $ s ( c_j + \\Delta , X_1 ) $ to search for the new entry . More explanation for Equation ( 4 ) and a clearer presentation of the algorithm ( e.g.use an Algorithm module ) is preferred . * * Answer : * * When $ c_j + \\Delta $ is used to update our estimated center since the real center of each class is unknown , we use selected samples in previous steps to modify it . We then compute the sample which is closest to the new center $ c_j + \\Delta $ and return the sample ."}, {"review_id": "u846Bqhry_-1", "review_text": "# Summary This paper works on long-tailed classification . The authors conducted an analysis and claimed that the difference of gradients computed on the head and tail classes plays an important role in the performance drop . The authors then proposed a two-stage approach to first train on the head classes and then train on the tail classes in an incremental learning fashion . The proposed algorithm achieved better performance than existing methods on benchmark datasets . # Strengths - The analysis of the gradients between the head and tail classes seems to be novel . - The proposed methods achieve good performance on benchmark datasets . # Weaknesses 1 . The paper lacks a detailed description of how the gradient analysis is conducted . For example , is the gradient computed at some layers or all the layers ? How is the variance computed ? Is it possible that the relatively large variance is due to a smaller sample size of tail classes ? Why does the gradient computed on both types of classes have a larger norm ? I would suggest that the authors provided some equations . Moreover , given just Figure 1 and the difference to balanced training , it is still unclear if such a gradient difference really leads to poor long-tailed performance . An analysis of the relationship between gradients and the classification performance will make the paper stronger . 2.The idea of learning the classifier with two-phase has been proposed ( Kaidi Cao et al. , 2019 ; Kang et al. , 2020 ) . The most similar ones to the paper are [ A , B , C ] , in which the first stage only considers data-reach classes . The authors , however , failed to identify and discuss them . [ A ] Wang et al. , Frustratingly Simple Few-Shot Object Detection , ICML 2020 [ B ] Zhang et al. , A Study on Action Detection in the Wild , arxiv 2019 [ C ] Cui et al. , Large Scale Fine-Grained Categorization and Domain-Specific Transfer Learning , CVPR 2018 Memories are also used in ( Liu et al. , 2019 ) but the authors did not discuss it . 3.Details and motivations of the proposed methods are not clear , making it very hard to understand the proposed algorithm . - It is unclear why the memory bank is needed . Many existing works , including [ A , B , C ] , have proposed to simply train the second stage with all classes , with the subsampled class-balanced data , and shows promising results . Some of them even `` freeze '' the features but only train the classifier in the second stage . - The way the authors tackle the second-stage training is similar to incremental learning , but the authors failed to discuss those works . One example is [ D ] . [ D ] Rebuffi et al. , iCaRL : Incremental Classifier and Representation Learning , CVPR 2017 . - The design of Eq . ( 2 ) , ( 3 ) , ( 4 ) are not well-described and justified . Why do we need a new state ? Why do we need Delta ? The computation of Delta seems wrong : c_j + c_j -z_ { k+1 } = 2 * c_j \u2013 z_ { k+1 } ? Moreover , what does the state mean here ? - It is unclear why we need graphs . It is unclear what \u201c z \u201d stands for in Eq . ( 5 ) , ( 6 ) , ( 7 ) . It is unclear how a_ { ij } is computed . - The motivations and description of the intra-class loss in Eq . ( 8 ) is unclear . - I would suggest that the authors provide a figure for their algorithm architecture and pipelines . 4.Experiments and analysis : - Back to my comment in 1. , there is no analysis to further justify that gradient distortion is really the cause of the poor longtailed performance , and there is no analysis if the proposed algorithm resolves it . There is no analysis if graphs and memory banks are really needed . - It is unclear what Ours ( Plain ) refers to . What is the model without asynchronous modeling ? # Minor I would suggest that the authors replace `` asynchronous '' with other terms . The proposed algorithm is just a two-stage algorithm . There is no component of distributed learning and communications that require synchronization or not . # Justification While the proposed algorithm achieves promising results , the algorithm is not written , well-described , and motivated . It is also unclear if the gradient distortion is really the cause of poor long-tailed performance . I thus give a score of 3 . -- Post-rebuttal - I read the authors ' rebuttal and I appreciate their efforts . I would suggest that the authors incorporate those clarifications into their manuscript . I would also suggest that the authors re-motivate their paper and modify their approach section . In terms of the discussions to related work , I do think [ A , B , C ] is about long-tailed recognition/detection , not few-shot learning . For instance , [ A ] works on LVIS , a long-tailed object detection dataset ; [ C ] works on iNaturalist , which is clearly long-tailed . [ B ] 's Fig 1 clearly shows that the problem is long-tailed . I 'm surprised that the authors simply said that [ A , B , C , ] works on different problems but did not intend to discuss the similarity in methodologies . There are some very important questions not addressed yet , specifically , my comments 3 and 4 : There is no analysis if the proposed algorithm resolves gradient distortion . There is no analysis if graphs and memory banks are really needed . I also read other reviewers ' comments and I agree with R4 that the current version still lacks critical insights and some justifications are questionable . Given these , I would keep my initial score unchanged .", "rating": "3: Clear rejection", "reply_text": "Thank you for the detailed comment . We answer your questions point-by-point as below : 1 . Is the gradient computed at some layers or all the layers ? * * Answer : * * The gradient is computed at some layers . In Figure 1 , we show the gradient computed in the last FC layer . 2.How is the variance computed ? * * Answer : * * Take the norm of gradient for example , each iteration will return one value . We compute the mean and variance of the norms in every n iterations . 3.Is it possible that the relatively large variance is due to a smaller sample size of tail classes ? * * Answer : * * Yes , it is likely to lead to larger variance due to the limited samples in tail classes . 4.Why does the gradient computed on both types of classes have a larger norm ? I would suggest that the authors provided some equations . * * Answer : * * Suppose we denote $ x_1 $ as the gradient computed on head classes , and $ x_2 $ is the gradient computed on tail classes . The gradient computed on all classes is denoted as $ x $ , where $ x = x_1 + x_2 $ . The norm of $ x $ is computed as $ ||x||^2 = ||x_1||^2 + ||x_2||^2 + 2\\langle x_1 , x_2\\rangle $ . The overall gradient norm is possibly larger than $ ||x_1||^2 $ or $ ||x_2||^2 $ when $ ||x_2||^2 + 2\\langle x_1 , x_2\\rangle > 0 $ or $ ||x_1||^2 + 2\\langle x_1 , x_2\\rangle > 0 $ . 5.Moreover , given just Figure 1 and the difference to balanced training , it is still unclear if such a gradient difference really leads to poor long-tailed performance . An analysis of the relationship between gradients and the classification performance will make the paper stronger . * * Answer : * * Compared to the balanced case , the gradients in long-tailed data indeed exhibit different properties . Moreover , the results in our method outperform prior methods on a range of datasets , suggesting that separate consideration of gradients of head and tail is beneficial for long-tailed recognition . 6.The idea of learning the classifier with two-phase has been proposed . Discuss difference with A , B , C , D. Memories are also used in ( Liu et al. , 2019 ) but the authors did not discuss it . * * Answer : * * Discussion with ( Kang et al. , 2020 ) : ( Kang et al. , 2020 ) divides the feature learning and the classifier learning into two stages . Instead , we propose to separate the data into data-rich classes and data-poor classes . Discussion with A , B , C : A & C focus on few-shot classification or transfer learning , where the goal is to generalize well on a target dataset given a training dataset . We target long-tailed classification to improve the overall classification performance on both head and tail classes . Zhang et al . [ B ] proposes to transfer information from head to tail classes on action detection and trains the second stage simply by jointly fine-tuning . We introduce a memory bank and memory-retentive loss to realize the seamless connection between two data splits . Discussion with D : D tackles the incremental learning setting , which first considers part of the data and then involves the rest data . In our case , we first consider samples in head classes then consider data in the rest . However , different from D that directly considers the incremental setting , our goal in long tail is trying to boost the performance in long tail . Discussion with ( Liu et al. , 2019 ) : For the memory , we are different from ( Liu et al. , 2019 ) . ( Liu et al. , 2019 ) tries to compute the average feature in each class and strengthen the feature of new samples . In our paper , we reserve a few samples in head classes and the memory is used to keep the model retentive when it meets samples in new classes . 7.The design of Eq . ( 2 ) , ( 3 ) , ( 4 ) are not well-described and justified . Why do we need a new state ? Why do we need Delta ? The computation of Delta seems wrong : $ c_j + c_j -z_ { k+1 } = 2 * c_j \u2013 z_ { k+1 } $ ? Moreover , what does the state mean here ? * * Answer : * * Initially , $ c_j $ is the average of all feature maps in class $ j $ , which is just an estimation of the center . While selecting new samples to the memory bank , we also use the selected samples to adjust $ c_j $ . State $ z_ { k+1 } $ is the weighted average of selected samples . $ \\Delta $ is the difference between $ c_j $ and $ z_ { k+1 } $ , it can be reformulated as : $ \\Delta = \\sum_ { i } p_i ( c_j - m_i ) $ , which means the weighted deviation of selected sample from $ c_j $ . To fix the deviation , we have $ c_j + \\Delta $ ."}, {"review_id": "u846Bqhry_-2", "review_text": "Summary : - This paper proposes a two-stage learning algorithm to address imbalanced datasets . Only data-rich classes is used in the first representation learning stage . In the second stage , an exemplar memory bank with graph matching is used together with standard classification . Experimental results on benchmarks highlight the effectiveness of the proposed method . Pros : - The total experiments conducted are thorough and satisfactory . Cons : - The presentation of this paper can be improved . For example , the notation in Figure 1 is very hard to parse . The writing could be improved as well . There 's a chance that I did n't understand the paper so I just list all my concerns in questions . - In the implementation detail section , there 's only implementation details shared with the baseline . There 's no detail about the proposed method , e.g. , what 's the choice of $ \\lambda $ , s , how does the authors actually do the two-stage training . what is fixed and what is learned in the second stage ? Additional Questions : - For Figure 1 ( c ) and ( d ) , why is the L2 norm of the overall gradient larger than both grad1 and grad2 ? - What 's the rationale behind the design of memory bank ? To be more specific , what 's the rationale behind the design of Equation ( 3 ) , ( 4 ) ? - `` In contrast to the aforementioned strategies , we approach the long-tailed recognition problem by analyzing gradient distortion in long-tailed data '' How does the proposed method get connected with this statement and differ from other two-stage training algorithms ? - For equation ( 6 ) , what 's the intuition to use $ a_ { ji } $ to reweight each norm ? - For $ L_ { intra } $ , why do the authors choose hinge loss rather than cross entropy ? To the best of my knowledge , Hinge loss does not work well in deep learning , esperically with large amoung of classes as the gradient can be vary sparse . - post-rebuttal update I appreciate the authors for the responses . Some of my concerns have been addressed , so I increased my score . However , I this the current version still lacks critical insights and some justifications are questionable .", "rating": "5: Marginally below acceptance threshold", "reply_text": "We appreciate your review and answer the questions point-by-point . 1.In the implementation detail section , there 's only implementation details shared with the baseline . There 's no detail about the proposed method , e.g. , what 's the choice of \\lambda . how does the authors actually do the two-stage training . What is fixed and what is learned in the second stage ? * * Answer : * * We empirically set \\lambda to be $ \\sqrt { \\frac { num\\ old } { num\\ new } } $ , where \u201c num old \u201d indicates the number of classes in the first stage and \u201c num new \u201d is the number of new classes in the second stage . As discussed in the ablation , take Places-LT for example , we train the model on first 294 classes in stage one and then extend the classifier to involve the samples in rest 71 classes . While we learn new classes embeddings in the classifier in the second stage , the old class embeddings learned in the first stage also need to be tuned . 2.For Figure 1 ( c ) and ( d ) , why is the L2 norm of the overall gradient larger than both grad1 and grad2 ? * * Answer : * * Please see our response to AnonReviewer3 Q4 . 3.What 's the rationale behind the design of memory bank ? To be more specific , what 's the rationale behind the design of Equation ( 3 ) , ( 4 ) ? * * Answer : * * When applying the memory bank , we want to keep the model retentive by reserving a few samples in old classes . For example , we only reserve 10 samples in each old class . Ideally , we want to select the 10 samples that are closest to the center of each class . However , the real center is unknown and we want to upgrade the estimated center through selected samples in previous steps . This part has been updated that Equation ( 3 ) becomes Equation ( 4 ) and Equation ( 4 ) becomes Equation ( 5 ) . Equation ( 4 ) denotes a variable computed through selected samples in previous steps and Equation ( 5 ) returns the new selected sample . 4 . `` In contrast to the aforementioned strategies , we approach the long-tailed recognition problem by analyzing gradient distortion in long-tailed data '' How does the proposed method get connected with this statement and differ from other two-stage training algorithms ? * * Answer : * * Previous two-stage methods first train the model on the whole datasets then fine-tune the model on a balanced subset or balanced sampler . In our paper , we first show that the difference of gradients computed on head classes and tail classes , then split the dataset into head classes and tail classes . We first train the model on head classes then involve the rest . When we learn the rest in the second stage , we also finetune the classifier embeddings based on the constructed exemplar bank which selects a few samples in classes in the first stage . 5.For equation ( 6 ) , what 's the intuition to use to reweight each norm ? * * Answer : * * For one input , we not only consider the difference of its old feature map and new feature map but consider its difference between the neighbor points . Intuitively if the input is far away from its one neighbor , we will assign a smaller weight for the difference as penalty . That is $ a_ { ji } $ is used for . 6.For $ L_ { intra } $ , why do the authors choose hinge loss rather than cross entropy ? To the best of my knowledge , Hinge loss does not work well in deep learning , especially with large amount of classes as the gradient can be vary sparse . * * Answer : * * Loss $ L_ { intra } $ is not used for classification . It only works to avoid the case that the model classifies the samples in old classes to new classes when learning in the second stage . $ L_ { cls } $ is the one used for classification , which is a cross-entropy loss ."}, {"review_id": "u846Bqhry_-3", "review_text": "This paper proposes an interesting view to analyze the long-tailed problem . It states that the gradients are dominated by the head classes so that the tail classes perform poorly . From this observation , the authors propose a dual-phase approach that first train $ W_r , W_c^1 $ with only head-class data , and extend to train $ W_r , W_c $ with tail-class data and the constructed exemplar memory bank for head classes with a newly proposed memory retentive loss . # # # # Pros : 1 . This paper is well organized and written . 2.Analyzing through the gradient seems to be an interesting view , which could bring insights into the long-tailed problem . # # # # Some questions and concerns : 1 . In Fig.1 ( c ) ( d ) , despite the norm variance , I do n't understand why the `` norm of grad '' is larger than `` the norm of grad1 '' and `` the norm of grad2 '' . They are all norms , right ? So why the grad ( a combination of grad1 and grad2 in my opinion ) becomes larger ? 2.This dual-phase approach somehow seems similar to [ this paper ] ( https : //openaccess.thecvf.com/content_CVPR_2020/papers/Li_Overcoming_Classifier_Imbalance_for_Long-Tail_Object_Detection_With_Balanced_Group_CVPR_2020_paper.pdf ) , which actually groups categories that own a similar number of training instances and train the classifier separately . And this paper divides all categories into 2 groups ( head and tail ) , but with more complicated operations . 3.The authors conduct experiments on almost all common long-tailed classification datasets , which is great . But the improvements seem to be very limited on Places-LT , ImageNet-LT , iNaturalist18 comparing with recent works . It seems that it only works well on small datasets like CIFAR , which is somehow weak . 4.About the training schedule , in the Appendix.Implementation Details , it states that the number of training epochs is 200 . It means that we train both 200 epochs for both phase1 and phase2 right ? Though $ X_1 $ and $ X_2 $ are not overlapped , the exemplar bank will be trained twice . How much will it cost ? How is the cost comparing with re-sampling approaches ?", "rating": "6: Marginally above acceptance threshold", "reply_text": "Thank you for the positive feedback . We address your concerns as below . 1.Why the grad ( a combination of grad1 and grad2 in my opinion ) becomes larger ? * * Answer : * * Please see our response to AnonReviewer3 Q4 . 2.Discussion with paper `` Overcoming Classifier Imbalance for Long-tail Object Detection with Balanced Group Softmax '' . * * Answer : * * In their paper , they focus on long-tailed detection and try to utilize group softmax to deal with head and tail data . They still address all classes in the dataset simutinuously . Our method , however , tries to disentangle the effect between head and tail by two-stage learning and connects them through memory bank and memory-retentive loss . 3.The authors conduct experiments on almost all common long-tailed classification datasets , which is great . But the improvements seem to be very limited on Places-LT , ImageNet-LT , iNaturalist18 comparing with recent works . It seems that it only works well on small datasets like CIFAR , which is somehow weak . * * Answer : * * Take ImageNet-LT on ResNet-50 for example , we improve baseline 47.7 to ours 51.0. and Places-LT , we improve the baseline 37.6 to ours 40.4 . Even for IEM ( 39.7 ) that introduces large extra parameters and memory data , we still outperform it . 4.About the training schedule , in the Appendix.Implementation Details , it states that the number of training epochs is 200 . It means that we train both 200 epochs for both phase1 and phase2 right ? Though and are not overlapped , the exemplar bank will be trained twice . How much will it cost ? How is the cost comparing with re-sampling approaches ? * * Answer : * * Yes , for each phase , it will be trained 200 epochs . For samples in the exemplar bank , we only reserve 10 samples in each old class to keep the model memory-retentive . The samples are actually used to avoid the dramatic change of model when it meets new samples . Compared to re-sampling approaches that the classifier is fine-tuned by re-sampling on the whole dataset , the introduced memory cost actually will not introduce too much overhead ."}], "0": {"review_id": "u846Bqhry_-0", "review_text": "* * Overview : * * The paper considers the issue of gradient distortion in long-tailed recognition including shifted gradient direction towards data-rich classes and the enlarged variance introduced by data-poor classes . It proposes to disentangle the data-rich and data-poor classes and train a model via a dual-phase learning process . The experimental results proved the effectiveness of the method . * * Strengths : * * The observation is interesting and the method is reasonable . The memory retentive loss via graph matching in the second phase makes sense , and the method is well evaluated in four commonly used datasets . * * Weaknesses , questions , and suggestions : * * 1 . One of my main concerns is that the separation of the data-rich and data-poor classes is unnatural because the long-tailed distribution is continuous . The main idea of the method is kind of similar to that of Gidaris et al . [ 1 ] as the authors also cited , but in the few-shot setting in their paper , the separation of base and novel classes is more natural and reasonable . The issue of gradient distortion is addressed and is the motivation of the method , however , the variety in gradient does not necessarily lead to worse performance , and even when the data-rich classes are extracted for training in Phase I , the imbalance and shifting to the relatively rich classes still exists while being less informative because of fewer classes and less data . The trade-off is not easy to balance and could be sensitive to the disentanglement points as in Figure 3 , where 294 and 864 are carefully selected for Places-LT and ImageNer-LT This introduces limitation to the generality of the method . 2.Are the formations of equation ( 2 ) and ( 5 ) presented correctly ? Maybe the authors intend to present \\sum_i { exp { ... } } as the denominator ? 3.The presentation and clarity need to be improved . For example , - The caption for Figure 1 is too long and could be more concise , e.g. , to use 'titles ' to distinguish CIFAR100 and CIFAR100-LT ; to use grad_rich / grad_poor or something as the legend and save any extra explanation . Some of the details can be embedded in the main paper , and I \u2019 m not sure how are the gradient statistics calculated , layer-by-layer , or directly use the average of the whole network . It would be better to see it clarified in the paper or appendix , and sorry if I missed it . - There are double y-axis in Figure 2 and 3 , but there is no legend or caption showing each plot is assigned to which axis . - What does 'extended parameters ' mean in the experiment section ? 4.The performance improvement seems not significant compared with previous works , e.g.ImageNet-LT on ResNet-10 and iNaturalist . 5.I \u2019 m not sure I \u2019 ve correctly comprehended the construction of the exemplar memory bank and the reason why use s ( c_j + \\Delta , X_1 ) to search for the new entry . More explanation for Equation ( 4 ) and a clearer presentation of the algorithm ( e.g.use an Algorithm module ) is preferred . [ 1 ] Gidaris et al. , Dynamic few-shot visual learning without forgetting , in CVPR 2018 * * Post-Rebuttal * * After reading the rebuttal and other reviewers ' comments , I am actually on the fence for this submission . On the one hand , it provides several interesting observations about the phase transition in long-tailed recognition , which would be valuable to the community . On the other hand , its experimental evaluation needs to be strengthened . The authors are encouraged to include more many-shot/medium-shot/few-shot analysis across the dual phases . Therefore , I upgrade my score to 6 ( marginally above acceptance threshold ) .", "rating": "6: Marginally above acceptance threshold", "reply_text": "Thank you for recognizing that \u201c the observation is interesting and the method is reasonable \u201d . We answer your questions below : 1 . One of my main concerns is that the separation of the data-rich and data-poor classes is unnatural because the long-tailed distribution is continuous . The main idea of the method is kind of similar to that of Gidaris et al . [ 1 ] as the authors also cited , but in the few-shot setting in their paper , the separation of base and novel classes is more natural and reasonable . The issue of gradient distortion is addressed and is the motivation of the method , however , the variety in gradient does not necessarily lead to worse performance , and even when the data-rich classes are extracted for training in Phase I , the imbalance and shifting to the relatively rich classes still exists while being less informative because of fewer classes and less data . The trade-off is not easy to balance and could be sensitive to the disentanglement points as in Figure 3 , where 294 and 864 are carefully selected for Places-LT and ImageNer-LT This introduces limitation to the generality of the method . * * Answer : * * Gidaris et al . [ 1 ] considers the few-shot setting , which aims to quickly adapt to novel classes . Our separation of data-rich classes and data-poor classes is motivated by the gradient distortion phenomenon . For long-tailed classification , we not only consider the representation learning but the classification . Actually for head data , the tail data actually helps little in the representation learning since the limited samples . The classification of tail classes , however , will distract the classification of head classes . This is reflected by the gradient distortion between them . As we show in Figure 3 , though the final performance is affected by the specific threshold selected , but the change is minor . The final performance actually keeps rather stable in a wide range of threshold . 2.Are the formations of equation ( 2 ) and ( 5 ) presented correctly ? Maybe the authors intend to present \\sum_i { exp { ... } } as the denominator ? * * Answer : * * Sorry for the mistake , we will update it . 3.The presentation and clarity need to be improved . For example , the caption for Figure 1 is too long and could be more concise , e.g. , to use 'titles ' to distinguish CIFAR100 and CIFAR100-LT ; to use grad_rich / grad_poor or something as the legend and save any extra explanation . Some of the details can be embedded in the main paper , and I \u2019 m not sure how are the gradient statistics calculated , layer-by-layer , or directly use the average of the whole network . It would be better to see it clarified in the paper or appendix , and sorry if I missed it . * * Answer : * * Figure 1 will be updated . Here we simply show the gradient computed in the FC layer . 4.There are double y-axis in Figure 2 and 3 , but there is no legend or caption showing each plot is assigned to which axis . * * Answer : * * We will update the figure . In the paper , we have described \u201c Similarly , the axis for describing different shots is in the left . The change of overall result is depicted in the right of the figure , which is an independent axis \u201d . 5.What does 'extended parameters ' mean in the experiment section ? * * Answer : * * The extended parameters here means that they introduce extra modules and incorporate more parameters . 6.The performance improvement seems not significant compared with previous works , e.g.ImageNet-LT on ResNet-10 and iNaturalist . * * Answer : * * You are correct . For ImageNet-LT on ResNet-10 , the model is limited in its parameters , so the improvement is not significant . For iNaturalist , considering its scale ( 400K image ) , further improvement can be very difficult . 7.I \u2019 m not sure I \u2019 ve correctly comprehended the construction of the exemplar memory bank and the reason why use $ s ( c_j + \\Delta , X_1 ) $ to search for the new entry . More explanation for Equation ( 4 ) and a clearer presentation of the algorithm ( e.g.use an Algorithm module ) is preferred . * * Answer : * * When $ c_j + \\Delta $ is used to update our estimated center since the real center of each class is unknown , we use selected samples in previous steps to modify it . We then compute the sample which is closest to the new center $ c_j + \\Delta $ and return the sample ."}, "1": {"review_id": "u846Bqhry_-1", "review_text": "# Summary This paper works on long-tailed classification . The authors conducted an analysis and claimed that the difference of gradients computed on the head and tail classes plays an important role in the performance drop . The authors then proposed a two-stage approach to first train on the head classes and then train on the tail classes in an incremental learning fashion . The proposed algorithm achieved better performance than existing methods on benchmark datasets . # Strengths - The analysis of the gradients between the head and tail classes seems to be novel . - The proposed methods achieve good performance on benchmark datasets . # Weaknesses 1 . The paper lacks a detailed description of how the gradient analysis is conducted . For example , is the gradient computed at some layers or all the layers ? How is the variance computed ? Is it possible that the relatively large variance is due to a smaller sample size of tail classes ? Why does the gradient computed on both types of classes have a larger norm ? I would suggest that the authors provided some equations . Moreover , given just Figure 1 and the difference to balanced training , it is still unclear if such a gradient difference really leads to poor long-tailed performance . An analysis of the relationship between gradients and the classification performance will make the paper stronger . 2.The idea of learning the classifier with two-phase has been proposed ( Kaidi Cao et al. , 2019 ; Kang et al. , 2020 ) . The most similar ones to the paper are [ A , B , C ] , in which the first stage only considers data-reach classes . The authors , however , failed to identify and discuss them . [ A ] Wang et al. , Frustratingly Simple Few-Shot Object Detection , ICML 2020 [ B ] Zhang et al. , A Study on Action Detection in the Wild , arxiv 2019 [ C ] Cui et al. , Large Scale Fine-Grained Categorization and Domain-Specific Transfer Learning , CVPR 2018 Memories are also used in ( Liu et al. , 2019 ) but the authors did not discuss it . 3.Details and motivations of the proposed methods are not clear , making it very hard to understand the proposed algorithm . - It is unclear why the memory bank is needed . Many existing works , including [ A , B , C ] , have proposed to simply train the second stage with all classes , with the subsampled class-balanced data , and shows promising results . Some of them even `` freeze '' the features but only train the classifier in the second stage . - The way the authors tackle the second-stage training is similar to incremental learning , but the authors failed to discuss those works . One example is [ D ] . [ D ] Rebuffi et al. , iCaRL : Incremental Classifier and Representation Learning , CVPR 2017 . - The design of Eq . ( 2 ) , ( 3 ) , ( 4 ) are not well-described and justified . Why do we need a new state ? Why do we need Delta ? The computation of Delta seems wrong : c_j + c_j -z_ { k+1 } = 2 * c_j \u2013 z_ { k+1 } ? Moreover , what does the state mean here ? - It is unclear why we need graphs . It is unclear what \u201c z \u201d stands for in Eq . ( 5 ) , ( 6 ) , ( 7 ) . It is unclear how a_ { ij } is computed . - The motivations and description of the intra-class loss in Eq . ( 8 ) is unclear . - I would suggest that the authors provide a figure for their algorithm architecture and pipelines . 4.Experiments and analysis : - Back to my comment in 1. , there is no analysis to further justify that gradient distortion is really the cause of the poor longtailed performance , and there is no analysis if the proposed algorithm resolves it . There is no analysis if graphs and memory banks are really needed . - It is unclear what Ours ( Plain ) refers to . What is the model without asynchronous modeling ? # Minor I would suggest that the authors replace `` asynchronous '' with other terms . The proposed algorithm is just a two-stage algorithm . There is no component of distributed learning and communications that require synchronization or not . # Justification While the proposed algorithm achieves promising results , the algorithm is not written , well-described , and motivated . It is also unclear if the gradient distortion is really the cause of poor long-tailed performance . I thus give a score of 3 . -- Post-rebuttal - I read the authors ' rebuttal and I appreciate their efforts . I would suggest that the authors incorporate those clarifications into their manuscript . I would also suggest that the authors re-motivate their paper and modify their approach section . In terms of the discussions to related work , I do think [ A , B , C ] is about long-tailed recognition/detection , not few-shot learning . For instance , [ A ] works on LVIS , a long-tailed object detection dataset ; [ C ] works on iNaturalist , which is clearly long-tailed . [ B ] 's Fig 1 clearly shows that the problem is long-tailed . I 'm surprised that the authors simply said that [ A , B , C , ] works on different problems but did not intend to discuss the similarity in methodologies . There are some very important questions not addressed yet , specifically , my comments 3 and 4 : There is no analysis if the proposed algorithm resolves gradient distortion . There is no analysis if graphs and memory banks are really needed . I also read other reviewers ' comments and I agree with R4 that the current version still lacks critical insights and some justifications are questionable . Given these , I would keep my initial score unchanged .", "rating": "3: Clear rejection", "reply_text": "Thank you for the detailed comment . We answer your questions point-by-point as below : 1 . Is the gradient computed at some layers or all the layers ? * * Answer : * * The gradient is computed at some layers . In Figure 1 , we show the gradient computed in the last FC layer . 2.How is the variance computed ? * * Answer : * * Take the norm of gradient for example , each iteration will return one value . We compute the mean and variance of the norms in every n iterations . 3.Is it possible that the relatively large variance is due to a smaller sample size of tail classes ? * * Answer : * * Yes , it is likely to lead to larger variance due to the limited samples in tail classes . 4.Why does the gradient computed on both types of classes have a larger norm ? I would suggest that the authors provided some equations . * * Answer : * * Suppose we denote $ x_1 $ as the gradient computed on head classes , and $ x_2 $ is the gradient computed on tail classes . The gradient computed on all classes is denoted as $ x $ , where $ x = x_1 + x_2 $ . The norm of $ x $ is computed as $ ||x||^2 = ||x_1||^2 + ||x_2||^2 + 2\\langle x_1 , x_2\\rangle $ . The overall gradient norm is possibly larger than $ ||x_1||^2 $ or $ ||x_2||^2 $ when $ ||x_2||^2 + 2\\langle x_1 , x_2\\rangle > 0 $ or $ ||x_1||^2 + 2\\langle x_1 , x_2\\rangle > 0 $ . 5.Moreover , given just Figure 1 and the difference to balanced training , it is still unclear if such a gradient difference really leads to poor long-tailed performance . An analysis of the relationship between gradients and the classification performance will make the paper stronger . * * Answer : * * Compared to the balanced case , the gradients in long-tailed data indeed exhibit different properties . Moreover , the results in our method outperform prior methods on a range of datasets , suggesting that separate consideration of gradients of head and tail is beneficial for long-tailed recognition . 6.The idea of learning the classifier with two-phase has been proposed . Discuss difference with A , B , C , D. Memories are also used in ( Liu et al. , 2019 ) but the authors did not discuss it . * * Answer : * * Discussion with ( Kang et al. , 2020 ) : ( Kang et al. , 2020 ) divides the feature learning and the classifier learning into two stages . Instead , we propose to separate the data into data-rich classes and data-poor classes . Discussion with A , B , C : A & C focus on few-shot classification or transfer learning , where the goal is to generalize well on a target dataset given a training dataset . We target long-tailed classification to improve the overall classification performance on both head and tail classes . Zhang et al . [ B ] proposes to transfer information from head to tail classes on action detection and trains the second stage simply by jointly fine-tuning . We introduce a memory bank and memory-retentive loss to realize the seamless connection between two data splits . Discussion with D : D tackles the incremental learning setting , which first considers part of the data and then involves the rest data . In our case , we first consider samples in head classes then consider data in the rest . However , different from D that directly considers the incremental setting , our goal in long tail is trying to boost the performance in long tail . Discussion with ( Liu et al. , 2019 ) : For the memory , we are different from ( Liu et al. , 2019 ) . ( Liu et al. , 2019 ) tries to compute the average feature in each class and strengthen the feature of new samples . In our paper , we reserve a few samples in head classes and the memory is used to keep the model retentive when it meets samples in new classes . 7.The design of Eq . ( 2 ) , ( 3 ) , ( 4 ) are not well-described and justified . Why do we need a new state ? Why do we need Delta ? The computation of Delta seems wrong : $ c_j + c_j -z_ { k+1 } = 2 * c_j \u2013 z_ { k+1 } $ ? Moreover , what does the state mean here ? * * Answer : * * Initially , $ c_j $ is the average of all feature maps in class $ j $ , which is just an estimation of the center . While selecting new samples to the memory bank , we also use the selected samples to adjust $ c_j $ . State $ z_ { k+1 } $ is the weighted average of selected samples . $ \\Delta $ is the difference between $ c_j $ and $ z_ { k+1 } $ , it can be reformulated as : $ \\Delta = \\sum_ { i } p_i ( c_j - m_i ) $ , which means the weighted deviation of selected sample from $ c_j $ . To fix the deviation , we have $ c_j + \\Delta $ ."}, "2": {"review_id": "u846Bqhry_-2", "review_text": "Summary : - This paper proposes a two-stage learning algorithm to address imbalanced datasets . Only data-rich classes is used in the first representation learning stage . In the second stage , an exemplar memory bank with graph matching is used together with standard classification . Experimental results on benchmarks highlight the effectiveness of the proposed method . Pros : - The total experiments conducted are thorough and satisfactory . Cons : - The presentation of this paper can be improved . For example , the notation in Figure 1 is very hard to parse . The writing could be improved as well . There 's a chance that I did n't understand the paper so I just list all my concerns in questions . - In the implementation detail section , there 's only implementation details shared with the baseline . There 's no detail about the proposed method , e.g. , what 's the choice of $ \\lambda $ , s , how does the authors actually do the two-stage training . what is fixed and what is learned in the second stage ? Additional Questions : - For Figure 1 ( c ) and ( d ) , why is the L2 norm of the overall gradient larger than both grad1 and grad2 ? - What 's the rationale behind the design of memory bank ? To be more specific , what 's the rationale behind the design of Equation ( 3 ) , ( 4 ) ? - `` In contrast to the aforementioned strategies , we approach the long-tailed recognition problem by analyzing gradient distortion in long-tailed data '' How does the proposed method get connected with this statement and differ from other two-stage training algorithms ? - For equation ( 6 ) , what 's the intuition to use $ a_ { ji } $ to reweight each norm ? - For $ L_ { intra } $ , why do the authors choose hinge loss rather than cross entropy ? To the best of my knowledge , Hinge loss does not work well in deep learning , esperically with large amoung of classes as the gradient can be vary sparse . - post-rebuttal update I appreciate the authors for the responses . Some of my concerns have been addressed , so I increased my score . However , I this the current version still lacks critical insights and some justifications are questionable .", "rating": "5: Marginally below acceptance threshold", "reply_text": "We appreciate your review and answer the questions point-by-point . 1.In the implementation detail section , there 's only implementation details shared with the baseline . There 's no detail about the proposed method , e.g. , what 's the choice of \\lambda . how does the authors actually do the two-stage training . What is fixed and what is learned in the second stage ? * * Answer : * * We empirically set \\lambda to be $ \\sqrt { \\frac { num\\ old } { num\\ new } } $ , where \u201c num old \u201d indicates the number of classes in the first stage and \u201c num new \u201d is the number of new classes in the second stage . As discussed in the ablation , take Places-LT for example , we train the model on first 294 classes in stage one and then extend the classifier to involve the samples in rest 71 classes . While we learn new classes embeddings in the classifier in the second stage , the old class embeddings learned in the first stage also need to be tuned . 2.For Figure 1 ( c ) and ( d ) , why is the L2 norm of the overall gradient larger than both grad1 and grad2 ? * * Answer : * * Please see our response to AnonReviewer3 Q4 . 3.What 's the rationale behind the design of memory bank ? To be more specific , what 's the rationale behind the design of Equation ( 3 ) , ( 4 ) ? * * Answer : * * When applying the memory bank , we want to keep the model retentive by reserving a few samples in old classes . For example , we only reserve 10 samples in each old class . Ideally , we want to select the 10 samples that are closest to the center of each class . However , the real center is unknown and we want to upgrade the estimated center through selected samples in previous steps . This part has been updated that Equation ( 3 ) becomes Equation ( 4 ) and Equation ( 4 ) becomes Equation ( 5 ) . Equation ( 4 ) denotes a variable computed through selected samples in previous steps and Equation ( 5 ) returns the new selected sample . 4 . `` In contrast to the aforementioned strategies , we approach the long-tailed recognition problem by analyzing gradient distortion in long-tailed data '' How does the proposed method get connected with this statement and differ from other two-stage training algorithms ? * * Answer : * * Previous two-stage methods first train the model on the whole datasets then fine-tune the model on a balanced subset or balanced sampler . In our paper , we first show that the difference of gradients computed on head classes and tail classes , then split the dataset into head classes and tail classes . We first train the model on head classes then involve the rest . When we learn the rest in the second stage , we also finetune the classifier embeddings based on the constructed exemplar bank which selects a few samples in classes in the first stage . 5.For equation ( 6 ) , what 's the intuition to use to reweight each norm ? * * Answer : * * For one input , we not only consider the difference of its old feature map and new feature map but consider its difference between the neighbor points . Intuitively if the input is far away from its one neighbor , we will assign a smaller weight for the difference as penalty . That is $ a_ { ji } $ is used for . 6.For $ L_ { intra } $ , why do the authors choose hinge loss rather than cross entropy ? To the best of my knowledge , Hinge loss does not work well in deep learning , especially with large amount of classes as the gradient can be vary sparse . * * Answer : * * Loss $ L_ { intra } $ is not used for classification . It only works to avoid the case that the model classifies the samples in old classes to new classes when learning in the second stage . $ L_ { cls } $ is the one used for classification , which is a cross-entropy loss ."}, "3": {"review_id": "u846Bqhry_-3", "review_text": "This paper proposes an interesting view to analyze the long-tailed problem . It states that the gradients are dominated by the head classes so that the tail classes perform poorly . From this observation , the authors propose a dual-phase approach that first train $ W_r , W_c^1 $ with only head-class data , and extend to train $ W_r , W_c $ with tail-class data and the constructed exemplar memory bank for head classes with a newly proposed memory retentive loss . # # # # Pros : 1 . This paper is well organized and written . 2.Analyzing through the gradient seems to be an interesting view , which could bring insights into the long-tailed problem . # # # # Some questions and concerns : 1 . In Fig.1 ( c ) ( d ) , despite the norm variance , I do n't understand why the `` norm of grad '' is larger than `` the norm of grad1 '' and `` the norm of grad2 '' . They are all norms , right ? So why the grad ( a combination of grad1 and grad2 in my opinion ) becomes larger ? 2.This dual-phase approach somehow seems similar to [ this paper ] ( https : //openaccess.thecvf.com/content_CVPR_2020/papers/Li_Overcoming_Classifier_Imbalance_for_Long-Tail_Object_Detection_With_Balanced_Group_CVPR_2020_paper.pdf ) , which actually groups categories that own a similar number of training instances and train the classifier separately . And this paper divides all categories into 2 groups ( head and tail ) , but with more complicated operations . 3.The authors conduct experiments on almost all common long-tailed classification datasets , which is great . But the improvements seem to be very limited on Places-LT , ImageNet-LT , iNaturalist18 comparing with recent works . It seems that it only works well on small datasets like CIFAR , which is somehow weak . 4.About the training schedule , in the Appendix.Implementation Details , it states that the number of training epochs is 200 . It means that we train both 200 epochs for both phase1 and phase2 right ? Though $ X_1 $ and $ X_2 $ are not overlapped , the exemplar bank will be trained twice . How much will it cost ? How is the cost comparing with re-sampling approaches ?", "rating": "6: Marginally above acceptance threshold", "reply_text": "Thank you for the positive feedback . We address your concerns as below . 1.Why the grad ( a combination of grad1 and grad2 in my opinion ) becomes larger ? * * Answer : * * Please see our response to AnonReviewer3 Q4 . 2.Discussion with paper `` Overcoming Classifier Imbalance for Long-tail Object Detection with Balanced Group Softmax '' . * * Answer : * * In their paper , they focus on long-tailed detection and try to utilize group softmax to deal with head and tail data . They still address all classes in the dataset simutinuously . Our method , however , tries to disentangle the effect between head and tail by two-stage learning and connects them through memory bank and memory-retentive loss . 3.The authors conduct experiments on almost all common long-tailed classification datasets , which is great . But the improvements seem to be very limited on Places-LT , ImageNet-LT , iNaturalist18 comparing with recent works . It seems that it only works well on small datasets like CIFAR , which is somehow weak . * * Answer : * * Take ImageNet-LT on ResNet-50 for example , we improve baseline 47.7 to ours 51.0. and Places-LT , we improve the baseline 37.6 to ours 40.4 . Even for IEM ( 39.7 ) that introduces large extra parameters and memory data , we still outperform it . 4.About the training schedule , in the Appendix.Implementation Details , it states that the number of training epochs is 200 . It means that we train both 200 epochs for both phase1 and phase2 right ? Though and are not overlapped , the exemplar bank will be trained twice . How much will it cost ? How is the cost comparing with re-sampling approaches ? * * Answer : * * Yes , for each phase , it will be trained 200 epochs . For samples in the exemplar bank , we only reserve 10 samples in each old class to keep the model memory-retentive . The samples are actually used to avoid the dramatic change of model when it meets new samples . Compared to re-sampling approaches that the classifier is fine-tuned by re-sampling on the whole dataset , the introduced memory cost actually will not introduce too much overhead ."}}