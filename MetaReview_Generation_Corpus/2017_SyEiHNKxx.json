{"year": "2017", "forum": "SyEiHNKxx", "title": "A Differentiable Physics Engine for Deep Learning in Robotics", "decision": "Invite to Workshop Track", "meta_review": "Originality, significance:\n  The paper implements a physics-based simulator directly using Theano. This avoids the type of finite differentiation that physics engines such as MuJoCo use to compute derivatives. It is quite an interesting idea, and is demonstrated using learned control for several models. \n \n Quality, clarity:\n  The original version was somewhat loosely written; the current version is improved.\n \n Pros:\n - The nice idea of implementing a physics engine in a language such as Theano, and showing that this is quite feasible.\n - May inspire further work in this direction.\n \n Cons:\n - The speed is not systematically evaluated, as compared to finite-difference-based engines. It is thought to be \"in the same ballpark\" as other more full-featured engines. It is not clear that those using simulators will care whether it uses the true derivatives or finite differences.", "reviews": [{"review_id": "SyEiHNKxx-0", "review_text": "I would definitely love to have this and use it for my research. A great tool. However, the paper lacks detail. In particular, I feel that it is impossible for someone to reimplement the research-mostly because of the lack of detail. However, replicability is a crucial part of science. Other publications proposing software (e.g. the tensorflow, theano and edward papers) come along with open source code. This is not the case here and therefore the picture is quite incomplete. I am not convinced that ICLR is the right venue: robotics conferences such as IROS and ICRA might appreciate it much more. Nevertheless, this is just an encouragement to the authors to interact with those communities.", "rating": "5: Marginally below acceptance threshold", "reply_text": "Thank you for your kind review . The goal is indeed to open source this library . However , as it currently stands , the reviews are around the acceptance threshold . I would rather not jeopardize this publication at possibly other conferences by opening the code before it is accepted for publication . If it were not for the open review process , the code would already have been included with the paper . As it stands now , all I can give is my word that it will be made open source . I am however unfamiliar with an open review process , and the reason I see no way around this issue might by my inexperience . Perhaps I could invite you personally to inspect the repository if you mail me an anonymous github account ? Perhaps you see another possibility ? > I am not convinced that ICLR is the right venue : robotics conferences such as IROS and ICRA might appreciate it much more . We have presented work at those robotics conferences before . In our experience , they usually have little - although growing - focus on machine learning results . We think that this physics engine could form a strong prior for machine learning in robotics , and that it is not yet common to use machine learning libraries this way . Or to formulate a prior for a neural network in this way . We thought this falls within the scope of ` learning representations ' . On top of that , we have presented this work at the deep reinforcement learning workshop at NIPS on invitation of the organizers . For these reasons , we believe that this work does fall within the context of ICLR . On a more personal level : I am quite environment minded , and ICLR is reachable by train this year , while both IROS and ICRA require intercontinental flights ."}, {"review_id": "SyEiHNKxx-1", "review_text": "A differentiable physics engine is indeed a wonderful thing to have. The key selling point of the proposed software is its speed, however there is no comparison to other physics engines. Besides describing the engine's speed in rather creative units (e.g. \"model seconds per day\"), the reader has no idea if this is fast or slow. Todorov's engine (my simulator of choice) computes a dynamics step and its derivatives wrt both states and controls (using finite-differences) in less than 1ms for a *full humanoid* model (his code is available here mujoco.org/book/programming.html#saDerivative). I think this actually faster than the engine described in this paper, but I can't be sure. Because this engine is so limited in what it can collide (sphere/sphere and sphere/plane), it would be trivial to build the example models in several other popular engines (e.g. ODE, Bullet and MuJoCo) and simply compare the performance. Until this comparison is done I consider the paper to be incomplete.", "rating": "5: Marginally below acceptance threshold", "reply_text": "Thank you for agreeing with this idea . We updated the paper , in order to clarify the speed of the engine . The dynamics step in our engine for a 100 state model is 1ms on GPU , so both engines are in the same ballpark . This comparison is however not fair , and we believe also not the point of our paper . We chose not to compare directly with other engines for the following reasons : * we believe that such a comparison would not be fair , as our engine currently is less feature complete . We think that comparing to systems which do have full collision detection is pointless for this reason . Comparing with engines which can not differentiate is equally pointless . * on the other hand , our gradient is analytically exact . * our focus was on efficient parallelization of computation , as we think this is a more relevant requirement for deep learning . This is not the case for these other engines . * nevertheless , as we claimed in the paper : `` Our implementation and our model can probably be made more efficient . '' We did not ( yet ) work to have this approach be as fast as possible . We believe that our paper deserves publication for the following novel ideas : * it is feasible to evaluate exact gradients of these robotic frameworks within a reasonable time . Exact gradients should form a favorable approach to finite differences when the number of states of the system rises drastically , for instance when manipulating cloth . * the recent automatic differentiation libraries are powerful enough to become an important tool in the differentiation of robot models . In order to add more novelty to this approach in this paper , we have added a fourth example to this paper . In this example , the controller relies on a differentiable camera in the differentiable physics engine in order to control a system . We believe that the use of differentiable cameras is a new approach to learning vision in robotics . We hope that in your view , this pushes this paper above the acceptance threshold ."}, {"review_id": "SyEiHNKxx-2", "review_text": "This paper creates a physics simulator using theano, and uses it to learn a neural network policy by back propagating gradients through the simulation. The approach is novel, and is motivated by being able to learn policies for robotics. My two key reservations with the paper are as follows: 1. The method is motivated by learning policies for robotics. However, the proposed method is *only* useful for robotics if the learned policy can transfer the real world. Transferring policies from simulation to real-world is an open research problem, and is particularly challenging with less realistic simulators. 2. They key novelty/benefit of this approach over other model-based approaches is that the simulator is differentiable. However, the only empirical comparison in the paper is to a model-free approach (CMA-ES). To appropriately demonstrate the approach, it should be compared to other model-based approaches, which do not require analytic derivatives of the model. For the reader to fully understand the pros and cons of the approach, the paper should also include quantitative comparison between the speed of the proposed simulator, and that of standard simulation platforms. Because the idea is interesting and novel, I think it lies above the acceptance threshold. However, it would be significantly improved with the aforementioned comparisons. Lastly, the writing of the paper could be improved, as it is rather informal and/or imprecise in a number of places. Here are some examples: -- \u201cwe model the use of a neural network as a general controller for a robot\u201d - can be more concisely phrased as something like \u201cwe model the robot controller using a neural network\u201d or \u201cthe robot controller is modeled using a neural network\" -- \u201cIn previous research, finding a gradient\u2026\u201d - This is a run-on sentence. -- \u201cWe basically jam this entire equation into\u201d - This sentence is informal and imprecise. -- \u201cdeep learning neural network\u201d - the word \u201clearning\u201d should be omitted -- \u201cone big RNN, where we unfold over time\u201d - should be \u201c\u2026RNN, which we unfold over time\u201d or \u201c\u2026RNN, unfolded over time\u201d The writing would also be improved by making it more concise and fitting the paper into 8 pages.", "rating": "6: Marginally above acceptance threshold", "reply_text": "Thank you for your remarks . We have indeed removed informal and imprecise wording from our paper to the best of our capabilities , including the ones you have mentioned . Some details have been moved to the appendix and other paragraphs have been made more concise to fit the paper into 8 pages . However , as long as the engine is not feature complete , we feel it is no use to perform quantitative speed comparisons with other engines . The comparison would not be a fair one . We believe the novelty lies indeed in the following : * it is feasible to evaluate exact gradients of these robotic frameworks within a reasonable time . Exact gradients should form a favorable approach to finite differences when the number of states of the system rises drastically , for instance when manipulating cloth . * the recent automatic differentiation libraries are powerful enough to become an important tool in the differentiation of robot models . Instead , we have made more clear how fast our engine is on our small models . In order to add more novelty to this approach in this paper , we have added a fourth example to this paper . In this example , the controller relies on a differentiable camera in the differentiable physics engine in order to control a system . To the best of our knowledge , differentiable cameras are a new approach to learning vision in robotics as well ."}], "0": {"review_id": "SyEiHNKxx-0", "review_text": "I would definitely love to have this and use it for my research. A great tool. However, the paper lacks detail. In particular, I feel that it is impossible for someone to reimplement the research-mostly because of the lack of detail. However, replicability is a crucial part of science. Other publications proposing software (e.g. the tensorflow, theano and edward papers) come along with open source code. This is not the case here and therefore the picture is quite incomplete. I am not convinced that ICLR is the right venue: robotics conferences such as IROS and ICRA might appreciate it much more. Nevertheless, this is just an encouragement to the authors to interact with those communities.", "rating": "5: Marginally below acceptance threshold", "reply_text": "Thank you for your kind review . The goal is indeed to open source this library . However , as it currently stands , the reviews are around the acceptance threshold . I would rather not jeopardize this publication at possibly other conferences by opening the code before it is accepted for publication . If it were not for the open review process , the code would already have been included with the paper . As it stands now , all I can give is my word that it will be made open source . I am however unfamiliar with an open review process , and the reason I see no way around this issue might by my inexperience . Perhaps I could invite you personally to inspect the repository if you mail me an anonymous github account ? Perhaps you see another possibility ? > I am not convinced that ICLR is the right venue : robotics conferences such as IROS and ICRA might appreciate it much more . We have presented work at those robotics conferences before . In our experience , they usually have little - although growing - focus on machine learning results . We think that this physics engine could form a strong prior for machine learning in robotics , and that it is not yet common to use machine learning libraries this way . Or to formulate a prior for a neural network in this way . We thought this falls within the scope of ` learning representations ' . On top of that , we have presented this work at the deep reinforcement learning workshop at NIPS on invitation of the organizers . For these reasons , we believe that this work does fall within the context of ICLR . On a more personal level : I am quite environment minded , and ICLR is reachable by train this year , while both IROS and ICRA require intercontinental flights ."}, "1": {"review_id": "SyEiHNKxx-1", "review_text": "A differentiable physics engine is indeed a wonderful thing to have. The key selling point of the proposed software is its speed, however there is no comparison to other physics engines. Besides describing the engine's speed in rather creative units (e.g. \"model seconds per day\"), the reader has no idea if this is fast or slow. Todorov's engine (my simulator of choice) computes a dynamics step and its derivatives wrt both states and controls (using finite-differences) in less than 1ms for a *full humanoid* model (his code is available here mujoco.org/book/programming.html#saDerivative). I think this actually faster than the engine described in this paper, but I can't be sure. Because this engine is so limited in what it can collide (sphere/sphere and sphere/plane), it would be trivial to build the example models in several other popular engines (e.g. ODE, Bullet and MuJoCo) and simply compare the performance. Until this comparison is done I consider the paper to be incomplete.", "rating": "5: Marginally below acceptance threshold", "reply_text": "Thank you for agreeing with this idea . We updated the paper , in order to clarify the speed of the engine . The dynamics step in our engine for a 100 state model is 1ms on GPU , so both engines are in the same ballpark . This comparison is however not fair , and we believe also not the point of our paper . We chose not to compare directly with other engines for the following reasons : * we believe that such a comparison would not be fair , as our engine currently is less feature complete . We think that comparing to systems which do have full collision detection is pointless for this reason . Comparing with engines which can not differentiate is equally pointless . * on the other hand , our gradient is analytically exact . * our focus was on efficient parallelization of computation , as we think this is a more relevant requirement for deep learning . This is not the case for these other engines . * nevertheless , as we claimed in the paper : `` Our implementation and our model can probably be made more efficient . '' We did not ( yet ) work to have this approach be as fast as possible . We believe that our paper deserves publication for the following novel ideas : * it is feasible to evaluate exact gradients of these robotic frameworks within a reasonable time . Exact gradients should form a favorable approach to finite differences when the number of states of the system rises drastically , for instance when manipulating cloth . * the recent automatic differentiation libraries are powerful enough to become an important tool in the differentiation of robot models . In order to add more novelty to this approach in this paper , we have added a fourth example to this paper . In this example , the controller relies on a differentiable camera in the differentiable physics engine in order to control a system . We believe that the use of differentiable cameras is a new approach to learning vision in robotics . We hope that in your view , this pushes this paper above the acceptance threshold ."}, "2": {"review_id": "SyEiHNKxx-2", "review_text": "This paper creates a physics simulator using theano, and uses it to learn a neural network policy by back propagating gradients through the simulation. The approach is novel, and is motivated by being able to learn policies for robotics. My two key reservations with the paper are as follows: 1. The method is motivated by learning policies for robotics. However, the proposed method is *only* useful for robotics if the learned policy can transfer the real world. Transferring policies from simulation to real-world is an open research problem, and is particularly challenging with less realistic simulators. 2. They key novelty/benefit of this approach over other model-based approaches is that the simulator is differentiable. However, the only empirical comparison in the paper is to a model-free approach (CMA-ES). To appropriately demonstrate the approach, it should be compared to other model-based approaches, which do not require analytic derivatives of the model. For the reader to fully understand the pros and cons of the approach, the paper should also include quantitative comparison between the speed of the proposed simulator, and that of standard simulation platforms. Because the idea is interesting and novel, I think it lies above the acceptance threshold. However, it would be significantly improved with the aforementioned comparisons. Lastly, the writing of the paper could be improved, as it is rather informal and/or imprecise in a number of places. Here are some examples: -- \u201cwe model the use of a neural network as a general controller for a robot\u201d - can be more concisely phrased as something like \u201cwe model the robot controller using a neural network\u201d or \u201cthe robot controller is modeled using a neural network\" -- \u201cIn previous research, finding a gradient\u2026\u201d - This is a run-on sentence. -- \u201cWe basically jam this entire equation into\u201d - This sentence is informal and imprecise. -- \u201cdeep learning neural network\u201d - the word \u201clearning\u201d should be omitted -- \u201cone big RNN, where we unfold over time\u201d - should be \u201c\u2026RNN, which we unfold over time\u201d or \u201c\u2026RNN, unfolded over time\u201d The writing would also be improved by making it more concise and fitting the paper into 8 pages.", "rating": "6: Marginally above acceptance threshold", "reply_text": "Thank you for your remarks . We have indeed removed informal and imprecise wording from our paper to the best of our capabilities , including the ones you have mentioned . Some details have been moved to the appendix and other paragraphs have been made more concise to fit the paper into 8 pages . However , as long as the engine is not feature complete , we feel it is no use to perform quantitative speed comparisons with other engines . The comparison would not be a fair one . We believe the novelty lies indeed in the following : * it is feasible to evaluate exact gradients of these robotic frameworks within a reasonable time . Exact gradients should form a favorable approach to finite differences when the number of states of the system rises drastically , for instance when manipulating cloth . * the recent automatic differentiation libraries are powerful enough to become an important tool in the differentiation of robot models . Instead , we have made more clear how fast our engine is on our small models . In order to add more novelty to this approach in this paper , we have added a fourth example to this paper . In this example , the controller relies on a differentiable camera in the differentiable physics engine in order to control a system . To the best of our knowledge , differentiable cameras are a new approach to learning vision in robotics as well ."}}